{"version":3,"sources":["../src/index.ts","../src/const.ts","../src/exporter.ts"],"sourcesContent":["import { BasicTracerProvider, BatchSpanProcessor } from '@opentelemetry/sdk-trace-base'\nimport { Tracer, trace } from '@opentelemetry/api'\nimport { TeerExporter } from './exporter'\n\ninterface TeerTracerEdgeOptions {\n  apiKey: string\n  debug?: boolean\n  flushInterval?: number\n}\n\nexport class TeerTracerEdge {\n  private static instance: TeerTracerEdge | null = null\n  private provider: BasicTracerProvider\n  private tracer: Tracer\n  private exporter: TeerExporter\n\n  private constructor(options: TeerTracerEdgeOptions) {\n    // Create and configure the exporter\n    const exporter = new TeerExporter({\n      apiKey: options.apiKey,\n      debug: options.debug,\n    })\n    this.exporter = exporter\n\n    // Add the exporter to the provider\n    this.provider = new BasicTracerProvider({\n      spanProcessors: [new BatchSpanProcessor(exporter)],\n      forceFlushTimeoutMillis: options.flushInterval,\n    })\n\n    // Register the provider\n    trace.setGlobalTracerProvider(this.provider)\n\n    // Get the tracer\n    this.tracer = this.provider.getTracer('ai')\n  }\n\n  public static getInstance(options: TeerTracerEdgeOptions): TeerTracerEdge {\n    if (!TeerTracerEdge.instance) {\n      TeerTracerEdge.instance = new TeerTracerEdge(options)\n    }\n    return TeerTracerEdge.instance\n  }\n\n  public getTracer(): Tracer {\n    return this.tracer\n  }\n\n  public async shutdown(): Promise<void> {\n    await this.provider.shutdown()\n    TeerTracerEdge.instance = null\n  }\n}\n","export const getTeerEndpoint = () => {\n  return `http://track.teer.ai${process.env.NODE_ENV === 'development' ? ':5171' : ''}/v1/spans/bulk`\n}\n","import type { ReadableSpan, SpanExporter } from '@opentelemetry/sdk-trace-base'\nimport type { ExportResult } from '@opentelemetry/core'\nimport { getTeerEndpoint } from './const'\n\ninterface TelemetryOptions {\n  apiKey?: string\n  endpoint?: string\n  debug?: boolean\n  flushInterval?: number\n  sdkIntegration?: string\n}\n\ntype SerializableSpan = Omit<ReadableSpan, 'spanContext' | 'resource'> & {\n  spanContext: {\n    spanId: string\n    traceId: string\n    traceFlags: number\n  }\n}\n\nfunction reduceSpansUsage(spans: SerializableSpan[]) {\n  return spans.reduce(\n    (memo, span) => {\n      memo.input += Number(span.attributes['gen_ai.usage.input_tokens']) || 0\n      memo.output += Number(span.attributes['gen_ai.usage.output_tokens']) || 0\n\n      return memo\n    },\n    {\n      input: 0,\n      output: 0,\n      total: 0,\n    }\n  )\n}\n\nexport class TeerExporter implements SpanExporter {\n  private static instance: TeerExporter | null = null\n  private readonly debug: boolean = false\n  private readonly apiKey?: string\n  private readonly endpoint: string = getTeerEndpoint()\n\n  private readonly flushInterval: number = 5000\n  private readonly MAX_QUEUE_SIZE = 1000\n\n  private spanQueue: SerializableSpan[] = []\n  private flushIntervalId: ReturnType<typeof setInterval> | null = null\n  private isShuttingDown = false\n  private activeFlush: Promise<void> | null = null\n\n  constructor(options: TelemetryOptions = {}) {\n    if (TeerExporter.instance) {\n      return TeerExporter.instance\n    }\n\n    this.debug = options.debug ?? false\n    this.apiKey = options.apiKey\n    this.flushInterval = options.flushInterval ?? 5000\n\n    this.startFlushInterval()\n    TeerExporter.instance = this\n\n    this.logDebug('TeerExporter initialized')\n  }\n\n  private startFlushInterval(): void {\n    if (this.flushIntervalId === null && !this.isShuttingDown) {\n      this.flushIntervalId = setInterval(() => {\n        if (this.spanQueue.length > 0 && !this.activeFlush) {\n          this.flush().catch((err) => {\n            this.logDebug('Error during scheduled flush', err)\n          })\n        }\n      }, this.flushInterval)\n    }\n  }\n\n  private async flush(): Promise<void> {\n    if (this.spanQueue.length === 0 || this.activeFlush) {\n      return\n    }\n\n    const spans = this.spanQueue.slice(0, this.MAX_QUEUE_SIZE)\n    this.spanQueue = this.spanQueue.slice(spans.length)\n\n    this.logDebug(`Flushing ${spans.length} spans`)\n\n    try {\n      this.activeFlush = this.sendSpans(spans)\n      await this.activeFlush\n    } finally {\n      this.activeFlush = null\n    }\n  }\n\n  private async sendSpans(spans: SerializableSpan[]): Promise<void> {\n    if (!this.apiKey) {\n      throw new Error('API key is required')\n    }\n\n    const usage = reduceSpansUsage(spans)\n    this.logDebug(`ðŸ“Š Model usage stats: ${usage.input} input + ${usage.output} output = ${usage.total} total tokens`)\n\n    try {\n      this.logDebug(`Spans: ${JSON.stringify(spans, null, 2)}`)\n\n      console.info(\n        'spans.request',\n        JSON.stringify(\n          {\n            url: this.endpoint,\n            method: 'POST',\n            headers: {\n              'Content-Type': 'application/json',\n              Authorization: `Bearer ${this.apiKey}`,\n            },\n            spans: spans.length,\n          },\n          null,\n          2\n        )\n      )\n\n      const response = await fetch(this.endpoint, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          Authorization: `Bearer ${this.apiKey}`,\n        },\n        body: JSON.stringify({ spans }),\n      })\n\n      console.log('response.ok?', response.ok)\n      if (!response.ok) {\n        const errorResponse = await response.json()\n        this.logDebug(`Error flushing spans`, JSON.stringify(errorResponse, null, 2))\n\n        throw new Error(`HTTP error: ${response.status} ${errorResponse.message}`)\n      }\n\n      this.logDebug(`Successfully flushed ${spans.length} spans`)\n    } catch (error) {\n      this.logDebug('Error flushing spans, will retry in next flush cycle', error)\n      // Put spans back in the queue\n      this.spanQueue = [...spans, ...this.spanQueue]\n      throw error\n    }\n  }\n\n  private enqueueSerializableSpans(spans: ReadableSpan[]): void {\n    for (const span of spans) {\n      const context = span.spanContext()\n\n      this.spanQueue.push({\n        name: span.name,\n        kind: span.kind,\n        startTime: span.startTime,\n        endTime: span.endTime,\n        status: span.status,\n        attributes: span.attributes,\n        links: span.links,\n        events: span.events,\n        duration: span.duration,\n        ended: span.ended,\n        // Note: resource has some subkeys which are not serializable but we could prune them and use the string values?\n        // resource: span.resource,\n        instrumentationScope: span.instrumentationScope,\n        droppedAttributesCount: span.droppedAttributesCount,\n        droppedEventsCount: span.droppedEventsCount,\n        droppedLinksCount: span.droppedLinksCount,\n        // Context add-ons\n        parentSpanContext: span.parentSpanContext,\n        spanContext: {\n          spanId: context.spanId,\n          traceId: context.traceId,\n          traceFlags: context.traceFlags,\n        },\n      })\n    }\n  }\n\n  async export(spans: ReadableSpan[], resultCallback: (result: ExportResult) => void): Promise<void> {\n    this.logDebug(`Exporting ${spans.length} spans`)\n\n    try {\n      this.enqueueSerializableSpans(spans)\n\n      resultCallback({ code: 0 })\n    } catch (error) {\n      this.logDebug('Error exporting spans', error)\n      resultCallback({\n        code: 1,\n        error: error instanceof Error ? error : new Error('Unknown error exporting spans'),\n      })\n    }\n  }\n\n  async shutdown(): Promise<void> {\n    this.logDebug('Shutting down')\n    this.isShuttingDown = true\n\n    if (this.flushIntervalId) {\n      clearInterval(this.flushIntervalId)\n      this.flushIntervalId = null\n    }\n\n    // Wait for any active flush to complete and flush remaining spans\n    if (this.activeFlush) {\n      await this.activeFlush\n    }\n    await this.flush()\n\n    TeerExporter.instance = null\n  }\n\n  async forceFlush(): Promise<void> {\n    this.logDebug('Force flushing spans')\n\n    if (this.activeFlush) {\n      await this.activeFlush\n    }\n\n    await this.flush()\n  }\n\n  private logDebug(message: string, ...args: any[]): void {\n    if (!this.debug) return\n    console.log(`[${new Date().toISOString()}] [TeerExporter] ${message}`, ...args)\n  }\n}\n"],"mappings":"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","names":[]}